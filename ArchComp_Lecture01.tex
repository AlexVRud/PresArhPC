\documentclass[9pt,pdf,ignorenonframetext,aspectratio=169]{beamer}

\usepackage{DejaVuSans}
\usepackage{DejaVuSerif}
\usepackage{DejaVuSansMono}
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage[russian]{babel}

\usepackage{hyperref}
\hypersetup{unicode=true}

\title[Введение в Ассемблер]{Архитектура компьютера}
\subtitle{Введение в Ассемблер}
\author[А.В. Рудалёв]{Александр Рудалёв}
\institute[ИМИКТ САФУ]{ИМИКТ САФУ}
\date[г. Архангельск, 2016 г.]{г. Архангельск, 2016 г.}

\usetheme{Madrid}
\usefonttheme[stillsansserifsmall]{serif}
%\usefonttheme[onlylarge]{structurebold}
\usefonttheme[onlylarge]{structureitalicserif}

\AtBeginSection[]{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\secname\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}

%\usepackage{pgfpages}
%\setbeameroption{show notes}
%\setbeameroption{show notes on second screen}

\usepackage[warn]{mathtext}          % русские буквы в формулах, с предупреждением
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}


\usepackage{color}
\usepackage{xcolor}
\usepackage{graphicx}

\usepackage{subfigure}

\usepackage{tikz}
\usetikzlibrary{calc}
\usetikzlibrary{arrows}
\usetikzlibrary{topaths}
\usetikzlibrary{positioning}
\usetikzlibrary{decorations.pathmorphing}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{backgrounds}
\usetikzlibrary{fit}
\usepackage{transparent}
\setbeamercovered{transparent}

\newcommand*{\ByteWidht}{0.9cm}
\newcommand*{\ByteHeight}{0.6cm}
\newcommand*{\DeltaWidht}{0.05cm}

\tikzset{
  databox/.style={draw,fill=white,minimum width=#1*\ByteWidht, minimum height=\ByteHeight, path picture={%
    \ifnum#1>1
      \foreach \x in {1,...,#1}%
        \draw (path picture bounding box.south west) ++(\x*\ByteWidht,0) -- ++(0,0.15*\ByteHeight);%
    \fi
    }
  },
  databox/.default=4,
  partleft/.style={minimum width=\ByteWidht, text width=0.6*\ByteWidht, minimum height=\ByteHeight, align=right,
    append after command={
      \pgfextra{%
        \draw [fill=lightgray]%
          ($(\tikzlastnode.south east) + (-0.65*\ByteWidht-0.5*\pgflinewidth,0.5*\pgflinewidth)$)
       -- ($(\tikzlastnode.south east) + (-0.5*\pgflinewidth,0.5*\pgflinewidth)$)
       -- ($(\tikzlastnode.north east) + (-0.5*\pgflinewidth,-0.5*\pgflinewidth)$) %
       -- ++(-0.65*\ByteWidht,0) %
       -- ++(0.125*\ByteWidht,-0.25*\ByteHeight)
       -- ++(-0.25*\ByteWidht,-0.50*\ByteHeight)
       -- cycle;
      }	
    }
  },
  partright/.style={minimum width=\ByteWidht, text width=0.6*\ByteWidht, minimum height=\ByteHeight, align=left,
    append after command={
      \pgfextra{%
        \draw [fill=lightgray]%
          ($(\tikzlastnode.south west) + (0.65*\ByteWidht+0.5*\pgflinewidth,0.5*\pgflinewidth)$)
       -- ($(\tikzlastnode.south west) + (0.5*\pgflinewidth,0.5*\pgflinewidth)$)
       -- ($(\tikzlastnode.north west) + (0.5*\pgflinewidth,-0.5*\pgflinewidth)$) %
       -- ++(0.65*\ByteWidht,0) %
       -- ++(0.125*\ByteWidht,-0.25*\ByteHeight)
       -- ++(-0.25*\ByteWidht,-0.50*\ByteHeight)
       -- cycle;
      }
    }
  },
  linkedbyte/.style={shape=rectangle,rounded corners,draw=green!80!black,dashed,%
     minimum width=\ByteWidht+2*\DeltaWidht, minimum height=\ByteHeight+2*\DeltaWidht
  },
  code/.style={shape=rectangle, draw=green!50!black, anchor=north west, outer sep=0, inner sep = 0},
  qahigh/.style={fill=blue!40, minimum height=\baselineskip, inner sep=0, inner ysep=0, anchor=north west},
  state/.style={rectangle, draw=gray, thick},
  command/.style={rectangle, draw=gray, thick, fill=blue!20!white, rounded corners},
}

\newcommand{\qahigh}[1]{%
  \foreach \x in {#1} {%
    \node[qahigh] at (0, 1 * \baselineskip + -1 * \x * \baselineskip) {
% Example for use of graphics for highlighting
% uncomment and set graphics file for usage
%        \begin{flushright}
%        \includegraphics[height=\baselineskip]{graphics/left-arrow.pdf}
%        \end{flushright}
    };
  }
}

\usepackage{bytefield}
\newcommand{\colorbitbox}[3]{%
\rlap{\bitbox{#2}{\color{#1}\rule{\width}{\height}}}%
\bitbox{#2}{#3}}
\newcommand{\memsection}[4]{
	\bytefieldsetup{bitheight=#3\baselineskip}	% define the height of the memsection
	\bitbox[]{8}{
		\texttt{0x\uppercase{#1}}	 % print end address
		\\ \vspace{#3\baselineskip} \vspace{-2\baselineskip} \vspace{-#3pt} % do some spacing
		\texttt{0x\uppercase{#2}} % print start address
	}
	\rlap{\bitbox{16}{\color{white}\rule{\width}{\height}}}%
\bitbox{16}{#4} % print box with caption
}

\usepackage{listings}
\lstset{
        basicstyle=\ttfamily,
        keywordstyle=\bf,
        stringstyle=\bf,
        commentstyle=\it,
        showspaces=false,
        showstringspaces=false,
        showtabs=true,
        tabsize=4,
        breaklines=true,
	extendedchars=true,
	language={[x86masm]Assembler},
	morekeywords={global, extern, section, .text, .bss},
        escapeinside=\`\`,
        moredelim=**[is][\it]{`}{`},
        numbers=left,
        numberstyle=\tiny,
        numbersep=5pt,
        lineskip=0pt,aboveskip=0pt,belowskip=0pt, % Уменьшаем отступы для вставки в tikz
        framesep=0pt,rulesep=0px,framerule=0pt,   %
%        xleftmargin=8mm,
%        frame=single,framexleftmargin=8mm, xleftmargin=8mm,
}

\newcommand{\cl}[1]{\texttt{\bf #1}}

\begin{document}

\frame{\titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Основные элементы
%%
\section{Основные элементы}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Основные элементы
%%
\begin{frame}\frametitle{Основные элементы}
  \begin{columns}[T]
    \begin{column}[T]{5cm}
      \begin{block}{Байт}
        \begin{figure}
          \subfigure{\begin{tikzpicture}
\node[databox=1,text=blue] at (0,0) {'A'};
          \end{tikzpicture}}
          \subfigure{\begin{tikzpicture}
\node[databox=1, text=brown] at (0,0) {255};
          \end{tikzpicture}}
          \subfigure{\begin{tikzpicture}
\node[databox=1] at (0,0) {A0};
          \end{tikzpicture}}
        \end{figure}
      \end{block}
    \end{column}
    \begin{column}[T]{5cm}
      \begin{block}{Int32}
        \begin{figure}
          \subfigure{\begin{tikzpicture}
\node[databox=4,text=brown] at (0,0) {1234567890};
          \end{tikzpicture}}
        \end{figure}
      \end{block}
    \end{column}
  \end{columns}
  \begin{columns}[T]
    \begin{column}[T]{11cm}
      \begin{block}{Массив}
        \begin{figure}
          \subfigure{\begin{tikzpicture}
\foreach \x/\d in {0/{'H'}, 1/'e', 2/'l', 3/'l', 4/'o'}{
  \node[databox=1,text=blue] (tmp) at (\x*\ByteWidht,0) {\d};
  \node[text=green!80!black, below=0.03cm of tmp,scale=0.5] {\x};
}
\node[databox=1,text=brown] (tmp) at (5*\ByteWidht,0) {0};
\node[text=green!80!black, below=0.03cm of tmp,scale=0.5] {5};
          \end{tikzpicture}}
          \subfigure{\begin{tikzpicture}
\node[partleft] at (0,0) {...};
\begin{scope}[shift={(\ByteWidht,0)}]
\foreach \x/\d in {0/{'H'}, 1/'e', 2/'l', 3/'l', 4/'o'}{
  \node[databox=1,text=blue] (tmp) at (\x*\ByteWidht,0) {\d};
  \node[text=green!80!black, below=0.03cm of tmp,scale=0.5] {+\x};
}
\node[databox=1,text=brown] (tmp) at (5*\ByteWidht,0) {0};
\node[text=green!80!black, below=0.03cm of tmp,scale=0.5] {+5};
\end{scope}
\node[partright] at (7*\ByteWidht,0) {...};
          \end{tikzpicture}}
        \end{figure}
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Основные элементы
%%
%% TODO: Разбить на два слайда и дать пример определения на Си
%%
\begin{frame}[fragile]\frametitle{Основные элементы}
      \begin{block}{Структура}
        \begin{figure}
          \subfigure{\begin{tikzpicture}%[scale=0.85, every node/.style={transform shape}]
\node[databox=4,text=brown] (id) {7172421}; \node[above=0 of id,text=magenta]{id};
\node[databox=1,right=-\pgflinewidth of id,text=blue] (a) {'A'}; \node[above=0 of a,text=magenta]{a};
\node[databox=1,right=-\pgflinewidth of a,text=blue] (b) {'B'}; \node[above=0 of b,text=magenta]{b};
\node[databox=2,right=-\pgflinewidth of b,text=blue, fill=lightgray] (none) {}; \node[above=0.5*\ByteHeight of none,text=green!30!black]  (lnone) {Что это?}; \draw[->,draw=green!30!black,thick] (lnone) -- (none);
\node[databox=4,right=-\pgflinewidth of none,text=brown] (sum) {7172421};  \node[above=0 of sum,text=magenta]{sum};
          \end{tikzpicture}}
          \subfigure{\begin{tikzpicture}%[scale=0.95, every node/.style={transform shape}]
\node[partleft] (tmp) at (0,0) {...};
\node[databox=4,right=-\pgflinewidth of tmp,text=brown] (x) {x=421}; \node[above=0 of x,text=magenta]{x};
\node[databox=4,right=-\pgflinewidth of x,text=brown] (y) {y=123}; \node[above=0 of y,text=magenta]{y};
\node[partright,right=-\pgflinewidth of y] {...};
          \end{tikzpicture}}
        \end{figure}
      \end{block}
      \begin{block}{Сложная структура}
        \begin{figure}
\begin{bytefield}{32}
    \bitheader{0,3,4,7,8,15,16,18,19,31}\\
    \colorbitbox{white}{4}{\textcolor{magenta}{\scriptsize Version}} &
    \colorbitbox{white}{4}{\scriptsize \textcolor{magenta}{Header length}} &
    \colorbitbox{white}{8}{\scriptsize \textcolor{magenta}{Differentiated Services}} &
    \colorbitbox{white}{16}{\textcolor{magenta}{\scriptsize Total Length}}\\
    \colorbitbox{white}{16}{\textcolor{magenta}{\scriptsize Identification}} &
    \colorbitbox{white}{3}{\textcolor{magenta}{\scriptsize Flags}} &
    \colorbitbox{white}{13}{\textcolor{magenta}{\scriptsize Fragment Offset}}\\
    \colorbitbox{white}{8}{\textcolor{magenta}{\scriptsize Time to Live}} &
    \colorbitbox{white}{8}{\textcolor{magenta}{\scriptsize Protocol}} &
    \colorbitbox{white}{16}{\textcolor{magenta}{\scriptsize Header Checksum}}\\
    \end{bytefield}
        \end{figure}
      \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Основные элементы
%%
\begin{frame}[fragile]\frametitle{Основные элементы}
  \begin{block}{Листинг}
    \begin{figure}
      \begin{tikzpicture}[scale=0.6, every node/.style={scale=0.6}]
        \node[fill=white,anchor=north west, outer sep=0, inner sep = 3pt] at (0,0) {%
          \begin{minipage}{1\textwidth}
\begin{verbatim}
     1                                  global  _main
     2                                  extern  _ExitProcess@4
     3                                  extern  _printf
     4
     5                                  section .text   use32
     6                                  _main:
     7 00000000 A1[1D000000]                    mov     eax, [A]
     8 00000005 50                              push    eax
     9 00000006 8B1D[21000000]                  mov     ebx, [B]
    10 0000000C 53                              push    ebx
    11 0000000D 01D8                            add     eax, ebx
    12 0000000F 50                              push    eax
    13 00000010 68[00000000]                    push    msg
    14 00000015 E8(00000000)                    call    _printf
    15 0000001A B800000000                      mov     eax, 0
    16 0000001F 31C0                            xor     eax, eax
    17 00000021 50                              push    eax
    18 00000022 E8(00000000)                    call    _ExitProcess@4
    19
    20                                  section .data
    21 00000000 41203D2025640D0A        msg     db "A = %d", 13, 10,
    22 00000008 42203D2025640D0A                db "B = %d", 13, 10,
    23 00000010 41202B2042203D2025-             db "A + B = %d", 13, 10, 0
    24 00000019 640D0A00
    25 0000001D D4C3B2A1                A       dd 0xA1B2C3D4
    26 00000021 AE080000                B       dd 2222
\end{verbatim}
          \end{minipage}
        };
\only<2>{
        \draw[scale=0.6,draw=red,thick] (3pt+16*9pt,-7pt-24*18pt) rectangle ++(8*9pt+5pt,-3pt-1*16pt);
        \draw[scale=0.6,draw=red,thick] (4pt+51*9pt,-7pt-24*18pt) rectangle ++(10*9pt+5pt,-3pt-1*16pt);
};
      \end{tikzpicture}
    \end{figure}
  \end{block}
  \note<2>{Порядок байтов от младшего к старшему (little-endian).}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Основные элементы
%%
\begin{frame}[fragile]\frametitle{Основные элементы}
  \begin{block}{Дамп памяти}
    \begin{figure}
      \begin{tikzpicture}[scale=0.5, every node/.style={scale=0.5}]
        \node[fill=white] at (0,0) {%
          \begin{minipage}{0.98\textwidth}
\begin{verbatim}
00000000  4c 01 02 00 62 bc ee 54  e2 00 00 00 0e 00 00 00  |L...b..T........|
00000010  00 00 00 00 2e 74 65 78  74 00 00 00 00 00 00 00  |.....text.......|
00000020  00 00 00 00 27 00 00 00  64 00 00 00 8b 00 00 00  |....'...d.......|
00000030  00 00 00 00 05 00 00 00  20 00 50 60 2e 64 61 74  |........ .P`.dat|
00000040  61 00 00 00 00 00 00 00  00 00 00 00 25 00 00 00  |a...........%...|
00000050  bd 00 00 00 e2 00 00 00  00 00 00 00 00 00 00 00  |................|
00000060  40 00 30 c0 a1 1d 00 00  00 50 8b 1d 21 00 00 00  |@.0......P..!...|
00000070  53 01 d8 50 68 00 00 00  00 e8 00 00 00 00 b8 00  |S..Ph...........|
00000080  00 00 00 31 c0 50 e8 00  00 00 00 01 00 00 00 04  |...1.P..........|
00000090  00 00 00 06 00 08 00 00  00 04 00 00 00 06 00 11  |................|
000000a0  00 00 00 04 00 00 00 06  00 16 00 00 00 08 00 00  |................|
000000b0  00 14 00 23 00 00 00 07  00 00 00 14 00 41 20 3d  |...#.........A =|
000000c0  20 25 64 0d 0a 42 20 3d  20 25 64 0d 0a 41 20 2b  | %d..B = %d..A +|
000000d0  20 42 20 3d 20 25 64 0d  0a 00 d4 c3 b2 a1 ae 08  | B = %d.........|
000000e0  00 00 2e 66 69 6c 65 00  00 00 00 00 00 00 fe ff  |...file.........|
000000f0  00 00 67 01 6c 61 62 30  33 2e 61 73 6d 00 00 00  |..g.lab03.asm...|
00000100  00 00 00 00 00 00 2e 74  65 78 74 00 00 00 00 00  |.......text.....|
00000110  00 00 01 00 00 00 03 01  27 00 00 00 05 00 00 00  |........'.......|
00000120  00 00 00 00 00 00 00 00  00 00 2e 64 61 74 61 00  |...........data.|
00000130  00 00 00 00 00 00 02 00  00 00 03 01 25 00 00 00  |............%...|
00000140  00 00 00 00 00 00 00 00  00 00 00 00 00 00 2e 61  |...............a|
00000150  62 73 6f 6c 75 74 00 00  00 00 ff ff 00 00 03 00  |bsolut..........|
00000160  00 00 00 00 04 00 00 00  00 00 00 00 00 00 00 00  |................|
00000170  02 00 5f 70 72 69 6e 74  66 00 00 00 00 00 00 00  |.._printf.......|
00000180  00 00 02 00 5f 6d 61 69  6e 00 00 00 00 00 00 00  |...._main.......|
00000190  01 00 00 00 02 00 6d 73  67 00 00 00 00 00 00 00  |......msg.......|
000001a0  00 00 02 00 00 00 03 00  41 00 00 00 00 00 00 00  |........A.......|
000001b0  1d 00 00 00 02 00 00 00  03 00 42 00 00 00 00 00  |..........B.....|
000001c0  00 00 21 00 00 00 02 00  00 00 03 00 40 66 65 61  |..!.........@fea|
000001d0  74 2e 30 30 01 00 00 00  ff ff 00 00 03 00 13 00  |t.00............|
000001e0  00 00 5f 45 78 69 74 50  72 6f 63 65 73 73 40 34  |.._ExitProcess@4|
\end{verbatim}
          \end{minipage}
        };
      \end{tikzpicture}
    \end{figure}
  \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Основные элементы
%%
\begin{frame}[fragile]\frametitle{Основные элементы}
      \begin{block}{Память (в документации)}
        \begin{figure}
\footnotesize{
\begin{bytefield}{24}
	\memsection{ffff ffff}{0040 0000}{6}{-- free --}\\
	\begin{rightwordgroup}{internal memory}
		\memsection{003f ffff}{002f c000}{4}{Special Function Registers}\\
		\memsection{002f bfff}{0007 0000}{3}{-- reseved --}\\
		\memsection{0006 ffff}{0000 0000}{6}{Internal Flash}
	\end{rightwordgroup}\\
\end{bytefield}
}
        \end{figure}
      \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Стек
%%
\section{Стек}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Структура данных <<стек>>
%%
\begin{frame}\frametitle{Структура данных <<стек>>}
  \begin{columns}[T]
    \begin{column}[T]{5cm}
      \begin{block}{Стек}
        \begin{figure}
          \begin{tikzpicture}
\node[databox=1,text=brown,anchor=south west] (s1) at (0,0) {1};
\node[databox=1,text=brown,anchor=south west] (s2) at (0,1*\ByteHeight) {2};
\node[databox=1,text=brown,anchor=south west] (s3) at (0,2*\ByteHeight) {3};
\draw[thick] (-0.1*\ByteWidht,5.1*\ByteHeight) --
             (-0.1*\ByteWidht,-0.1*\ByteHeight) --
             (1.1*\ByteWidht,-0.1*\ByteHeight) --
             (1.1*\ByteWidht,5.1*\ByteHeight);
\only<2>{
  \node[databox=1,text=brown,anchor=south west,fill=green!30!white] (s4in) at (-2.2*\ByteWidht,3*\ByteHeight) {4};
  \draw[->] (s4in) to[out=90,in=180] (-0.6*\ByteWidht,6*\ByteHeight) to[out=0,in=90] ($(s3) + (0,\ByteHeight)$);
}
\only<3,4>{
  \node[databox=1,text=brown,anchor=south west,fill=green!30!white] (s4) at (0,3*\ByteHeight) {4};
}
\only<3>{
  \draw[->,dotted] (-0.6*\ByteWidht,6*\ByteHeight) to[out=0,in=90] (s4);
}
\only<4>{
  \draw[->] (s4) to[out=90,in=180] (1.6*\ByteWidht,6*\ByteHeight);
}
\only<5>{
  \node[databox=1,text=brown,anchor=south west,fill=green!30!white] (s4out) at (2.2*\ByteWidht,3*\ByteHeight) {4};
  \draw[o->,dotted] ($(s3) + (0,\ByteHeight)$) to[out=90,in=180] (1.6*\ByteWidht,6*\ByteHeight) to[out=0,in=90] (s4out);
}
          \end{tikzpicture}
        \end{figure}
      \end{block}
    \end{column}
    \begin{column}[T]{5cm}
      \begin{block}{}
\only<1>{{\bf Стек} (англ. stack --- стопка; читается стэк) — структура данных, представляющая собой список элементов, организованных по принципу LIFO (англ. last in — first out, <<последним пришёл — первым вышел>>).}
\only<2,3>{<<Положить>> элемент в стек можно только на <<вершину>>.}
\only<4,5>{<<Взять>> из стека можно только верхний элемент.}
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Стек в памяти
%%
\begin{frame}\frametitle{Стек в памяти}
  \begin{block}{Стек}
    \begin{figure}
      \begin{tikzpicture}
\only<1>{
  \node[databox=1,text=brown,anchor=south west] (s3) at (0,0) {3};
  \node[databox=1,text=brown,anchor=south west] (s2) at (1*\ByteWidht,0) {2};
  \node[databox=1,text=brown,anchor=south west] (s1) at (2*\ByteWidht,0) {1};
  \draw[thick] (-1.1*\ByteWidht,-0.1*\ByteHeight) --
               (3.1*\ByteWidht,-0.1*\ByteHeight) --
               (3.1*\ByteWidht,1.1*\ByteHeight) --
               (-1.1*\ByteWidht,1.1*\ByteHeight);
}
\only<2,3>{
  \node[partleft] at (0,0) {...};
  \begin{scope}[shift={(\ByteWidht,0)}]
     \node[databox=3,fill=lightgray] at (1*\ByteWidht,0) {};
     \foreach \x/\d in {0/{3}, 1/{2}, 2/{1}}{
       \node[databox=1,text=brown] (tmp\x) at (3*\ByteWidht + \x*\ByteWidht,0) {\d};
       \node[text=green!80!black, below=0.03cm of tmp\x,scale=0.5] {+\x};
     }
  \end{scope}
  \node[partright] at (7*\ByteWidht,0) {...};
}
\only<3>{
  \node[linkedbyte] (headofstack) at (tmp0) {};
  \node[text=black, above=of headofstack] (ESP) {ESP};
  \draw[->,draw=violet,thick] (ESP) -- (headofstack);
}
\only<4>{
  \node[partleft] (tmp) at (0,0) {...};
  \node[databox=3,fill=lightgray, right=-\pgflinewidth of tmp] (tmp) {};
  \node[databox=4,text=brown,right=-\pgflinewidth of tmp] (tmpx) {1234567890};
  \node[linkedbyte,right=-\pgflinewidth-\DeltaWidht of tmp] (headofstack) {};
  \node[text=black, above=of headofstack] (ESP) {ESP};
  \draw[->,draw=violet,thick] (ESP) -- (headofstack);
  \node[databox=2,text=brown,right=-\pgflinewidth of tmpx] (tmpx) {1234};
  \node[databox=1,text=blue,right=-\pgflinewidth of tmpx] (tmpx) {'A'};
  \node[databox=1,text=blue,right=-\pgflinewidth of tmpx] (tmpx) {'B'};
  \node[partright,right=-\pgflinewidth of tmpx] {...};
}
      \end{tikzpicture}
    \end{figure}
  \end{block}
  \begin{block}{}
    \begin{itemize}
      \only<1>{%
        \item Теперь рассмотрим как стек храниться в памяти.
        \item Повернём его на бок.
        \item Тогда элементы стека будут расположены как в массиве
      }
      \only<2>{%
        \item И представление стека в памяти может быть таким.
      }
      \only<3>{%
        \item Добавим ссылку на вершину (позже узнаем почему именно ESP).
      }
      \only<4>{%
        \item В стеке могут храниться не только однобайтовые элементы.
        \item Но вершина стека --- это первый хранящейся байт в нём.
      }
    \end{itemize}
  \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Стек и процессор
%%
\begin{frame}\frametitle{Стек и процессор}
  \begin{block}{}
    \begin{itemize}
      \item Стек --- аппаратно реализованная структура в процессоре.
      \item Он хранится в специальном <<сегменте>> оперативной памяти.
      \item На вершину стека смотрит <<регистр процессора>> ESP.
      \item Для работы со стеком доступны команды {\bf push} и {\bf pop}.
      \item Стек используется не только для хранения данных, но и для вызова подпрограмм.
    \end{itemize}
  \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Регистры процессора
%%
\section{Регистры процессора}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Регистры процессора
%%
\begin{frame}\frametitle{Регистры процессора}
  \begin{block}{}
    \begin{itemize}
      \item Регистр процессора --- блок ячеек памяти, образующий сверхбыструю оперативную память внутри процессора
      \item Размер регистра, как правило зависит от разрядности процессора (или его режима).
      \item Регистры имеют имена: EAX, AX, ESP, EIP и т.д.
      \item Регистры разбиваются на функциональные группы, и не все они могут быть доступны программисту.
      \item В рамках курса мы рассмотрим только несколько видов регистров, доступных при программировании прикладного ПО.
    \end{itemize}
  \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Регистр AX
%%
\begin{frame}\frametitle{Регистр AX}
  \begin{block}{Регистр}
    \begin{figure}
      \begin{tikzpicture}
\only<1>{
  \node[databox=2,text=brown] (AX) at (0,0) {};
  \node[left=0cm of AX] {AX};
}
\only<2>{
  \node[databox=1] (AH) at (0,0) {B2};
  \node[databox=1,right=-\pgflinewidth of AH] (AL) {A1};
  \node[left=0cm of AH] {AX};
  \node[above=0cm of AH] {AH};
  \node[above=0cm of AL] {AL};
}
\only<3,4>{
  \node[databox=2] (EA16) at (0,0) {};
  \node[databox=1,right=-\pgflinewidth of EA16] (AH){};
  \node[databox=1,right=-\pgflinewidth of AH] (AL) {};
  \node[above=0cm of AH] {AH};
  \node[above=0cm of AL] {AL};
  \draw [decorate,decoration={brace,amplitude=5pt,mirror,raise=1pt}]
    (1*\ByteWidht,-0.5*\ByteHeight) -- (3*\ByteWidht,-0.5*\ByteHeight) node [midway,yshift=-12pt] {AX} ;
}
\only<3>{
  \node[left=0cm of EA16] {EAX};
}
\only<4>{
  \node[databox=4,left=-\pgflinewidth of EA16] (RA32) {};
  \node[left=0cm of RA32] {RAX};
  \draw [decorate,decoration={brace,amplitude=5pt,mirror,raise=1pt}]
    (-1*\ByteWidht,-0.5*\ByteHeight-15pt) -- (3*\ByteWidht,-0.5*\ByteHeight-15pt) node [midway,yshift=-12pt] {EAX} ;
}
\only<5>{
  \node[databox=1,text=brown] (EAX) at (0,0) {1234567890};
  \node[left=0cm of EAX] {EAX};
}
      \end{tikzpicture}
    \end{figure}
  \end{block}
  \begin{block}{}
    \begin{itemize}
      \only<1>{%
        \item AX --- 16-битный регистр общего назначения.
      }
      \only<2>{%
        \item Для доступа к младшему байту регистра AX используется имя AL.
        \item Для доступа к старшему байту регистра AX используется имя AH.
        \item В приведённом примере:
        \begin{itemize}
          \item AX=0xB2A2,
          \item AH=0xB2,
          \item AL=0xA1
        \end{itemize}
        \item Внимание!!! Регистры AL, AH, AX используют те же самые два байта в памяти!!!
      }
      \only<3>{%
        \item В 32-битном режиме регистр AX расширяется до регистра EAX.
        \item Доступ к частям регистра сохраняется.
        \item Например, для EAX=0xD4C3B2A1 получим, что:
        \begin{itemize}
          \item AX=0xB2A2,
          \item AH=0xB2,
          \item AL=0xA1
        \end{itemize}
      }
      \only<4>{%
        \item В 64-битном режиме регистр AX расширяется до регистра RAX.
        \item Все те же свойства, как и в 32-битном режиме, для регистра сохраняются.
      }
      \only<5>{%
        \item Для сокращения размера изображения, будем обозначать регистр простым блоком, т.к. его размер известен.
      }
    \end{itemize}
  \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Список регистров
%%
\begin{frame}\frametitle{Список регистров}
  \footnotesize
  \begin{columns}[T]
    \begin{column}[T]{5.5cm}
      \begin{block}{Общего назначения}
        \begin{itemize}
          \item RAX,EAX,AX,AH,AL (Аккумулятор)
          \item RBX,EBX,BX,BH,BL
          \item RCX,ECX,CX,CH,CL (Счётчик)
          \item RDX,EDX,DX,DH,DL
          \item R8-R15
        \end{itemize}
      \end{block}
      \begin{block}{Сегментные}
        \begin{itemize}
          \item CS (Code Segment)
          \item DS (Data Segment)
          \item SS (Stack Segment)
          \item ES (Extra Segment)
          \item FS
          \item GS
        \end{itemize}
      \end{block}
    \end{column}
    \begin{column}[T]{5.5cm}
      \begin{block}{Ссылки}
        \begin{itemize}
          \item RIP,EIP,IP (Следующая команда)
          \item RSP,ESP,SP,SPL (Стек)
          \item RBP,EBP,BP,BPL
          \item RSI,ESI,SI,SIL (Источник)
          \item RDI,EDI,DI,DIL (Назначение)
        \end{itemize}
      \end{block}
      \begin{block}{Регистр флагов}
        \begin{itemize}
          \item RFLAGS,EFLAGS,FLAGS
        \end{itemize}
      \end{block}
      \begin{block}{Системные регистры}
        \begin{itemize}
          \item ...
        \end{itemize}
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Введение в Ассемблер
%%
\section{Введение в Ассемблер}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Структура программы на Ассемблере
%%
\begin{frame}[fragile]\frametitle{Структура программы на Ассемблере}
  \begin{columns}[T]
    \begin{column}[T]{0.45\textwidth}
      \begin{exampleblock}{Hello world}
        \begin{figure}
          \begin{tikzpicture}[scale=0.8, every node/.style={scale=0.8}]
\node[code] at (0,0) {%
  \begin{minipage}{1.1\textwidth}
    \begin{lstlisting}[]
global  _main
extern  _ExitProcess@4
extern  _printf

section .text   use32
_main:
        push    msg
        call    _printf

        xor     eax, eax
        push    eax
        call    _ExitProcess@4
section .data
msg:    db "Hello World!!!", 13, 10, 0
    \end{lstlisting}
  \end{minipage}
};
\begin{pgfonlayer}{background}
  \begin{scope}[every node/.style={scale=0.8, text width=1.1\textwidth}]
    \only<1>{\qahigh{1,2,3,6}}
    \only<2>{\qahigh{5,13}}
    \only<3>{\qahigh{7,...,12}}
    \only<4>{\qahigh{14}}
  \end{scope}
\end{pgfonlayer}
          \end{tikzpicture}
        \end{figure}
      \end{exampleblock}
    \end{column}
    \begin{column}[T]{0.45\textwidth}
      \begin{block}{}
\only<1>{Объявление глобальных и используемых имён.}
\only<2>{Объявление секций кода и данных.}
\only<3>{Код программы.}
\only<4>{Константы}
      \end{block}
      \only<1>{\begin{block}{}
\footnotesize\it
{\bf global} --- сообщаем какие имена необходимо сделать видимыми в создаваемом объектном файле.

{\bf extern} --- какие имена нам понадобятся из других объектных файлов. Т.е., например, функции внешних библиотек.
      \end{block}}
      \only<3>{\begin{block}<3>{}
\footnotesize\it Как правило, используется выравнивание кода по трём колонкам шириной 8 символов:
метки, команды, параметры.
      \end{block}}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Команды языка Ассемблер: mov
%%
\begin{frame}[fragile]\frametitle{Команды языка Ассемблер: mov}
  \begin{block}<1->{Прототип}
    \cl{mov \{приёмник\}, \{источник\}}
  \end{block}
  \begin{block}<1->{}
    \begin{itemize}
      \item Команда \cl{mov} копирует значение из источника в приёмник.
      \item Приёмником может выступать регистр или участок памяти. Источником --- регистр, участок памяти или значение.
      \item Приёмник и источник должны быть одного размера.
      \item Один из операндов должен быть регистром.
    \end{itemize}
  \end{block}
  \begin{columns}[T]
    \begin{column}[]{0.45\textwidth}  
      \begin{exampleblock}<2->{Примеры}\footnotesize
\begin{lstlisting}[numbers=none]
; Поместить в регист eax число 123
        mov     eax, 123
; Поместить в регист eax значение переменной A
        mov     eax, [A]
; Поместить в регист eax адрес переменной msg
        mov     eax, msg
\end{lstlisting}
      \end{exampleblock}
    \end{column}
    \begin{column}[]{0.45\textwidth}  
      \begin{alertblock}<3->{Неправильные примеры}\footnotesize
\begin{lstlisting}[numbers=none]
; Пример №1
        mov     eax, bh
; Пример №2
        mov     [B], [A]
\end{lstlisting}
      \end{alertblock}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Пример mov eax,123
%%
\begin{frame}{Пример использования команды mov}
  \begin{columns}[T]
    \begin{column}[]{0.45\textwidth}  
      \begin{exampleblock}<1->{Пример}
        \begin{center}
\begin{tikzpicture}
  \node[databox=4,text=brown] (EAX1) at (0,0) {?};
  \node[left=0cm of EAX1] (LabelEAX1) {EAX};
  \node[state, fit=(EAX1) (LabelEAX1)] (State1) {};
  \node[databox=4,text=brown, below=2.5cm of EAX1] (EAX2) at (0,0) {\only<1,2>{123}\only<3,4>{1024}\only<5,6>{1234567890}\only<7,8>{0xA1B2C3D4}\only<9,10>{-1}};
  \node[left=0cm of EAX2] (LabelEAX2) {EAX};
  \node[state, fit=(EAX2) (LabelEAX2)] (State2) {};
  \node[command] (cmd) at($(State1)!0.5!(State2)$)  {\cl{mov eax, \only<1,2>{123}\only<3,4>{1024}\only<5,6>{1234567890}\only<7,8>{0xA1B2C3D4}\only<9,10>{-1}}};
  \draw[-o] (State1) -- (cmd);
  \draw[->] (cmd) -- (State2);
\end{tikzpicture}
        \end{center}
      \end{exampleblock}
    \end{column}
    \begin{column}[]{0.45\textwidth}  
      \begin{block}<1->{Вопрос}
        Чему стали равны \cl{AX}, \cl{AH}, \cl{AL}?
        \begin{center}
\begin{tikzpicture}
  \node[databox=2] (EA16) at (0,0) {};
  \node[databox=1,text=brown,right=-\pgflinewidth of EA16] (AH){\only<2>{0}\only<4>{4}\only<6>{2}\only<8>{\footnotesize 0xC3}\only<10>{\footnotesize 0xFF}};
  \node[databox=1,text=brown,right=-\pgflinewidth of AH] (AL) {\only<2>{123}\only<4>{0}\only<6>{150}\only<8>{\footnotesize 0xD4}\only<10>{\footnotesize 0xFF}};
  \node[text=brown, xshift=0.5*\ByteWidht] at (0,0) {\only<2>{0}\only<4>{0}\only<6>{210}\only<8>{\footnotesize 0xB2}\only<10>{\footnotesize 0xFF}};
  \node[text=brown, xshift=-0.5*\ByteWidht] at (0,0) {\only<2>{0}\only<4>{0}\only<6>{73}\only<8>{\footnotesize 0xA1}\only<10>{\footnotesize 0xFF}	};
  \node[above=0cm of AH] {AH};
  \node[above=0cm of AL] {AL};
  \draw [decorate,decoration={brace,amplitude=5pt,mirror,raise=1pt}]
    (1*\ByteWidht,-0.5*\ByteHeight) -- (3*\ByteWidht,-0.5*\ByteHeight) node [midway,yshift=-12pt] {AX} ;
  \node[left=0cm of EA16] {EAX};
\end{tikzpicture}
        \end{center}
\only<2>{\footnotesize $$123=0\cdot 256^3+0\cdot 256^2+0\cdot 256^1+123\cdot 256^0$$}
\only<4>{\footnotesize $$1024=0\cdot 256^3+0\cdot 256^2+4\cdot 256^1+0\cdot 256^0$$}
\only<6>{\footnotesize $$1234567890=73\cdot 256^3+210\cdot 256^2+$$
$$+2\cdot 256^1+150\cdot 256^0$$}
\only<8>{\footnotesize $$A1B2C3D4_{16}=A1_{16}\cdot 100_{16}^3+B2_{16}\cdot 100_{16}^2+$$
 $$+C3_{16}\cdot 100_{16}^1+D4_{16}\cdot 100_{16}^0$$}
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Команды языка Ассемблер: add
%%
\begin{frame}\frametitle{Команды языка Ассемблер: add}
  \begin{block}<1->{Прототип}
    \cl{add \{приёмник\}, \{источник\}}
  \end{block}
  \begin{block}<1->{}
    \begin{itemize}
      \item Команда сложения двух одинаковых целых чисел (\{приёмник\} и \{источнике\}).
      \item Результат сложения помещается в \{приёмник\}.
    \end{itemize}
  \end{block}
  \begin{exampleblock}<2->{Примеры}\footnotesize
    \cl{add eax, 123} \texttt{\it; Прибавить к регистру eax число 123}

    \cl{add eax, ebx} \texttt{\it; Прибавить к регистру eax регистр ebx}
  \end{exampleblock}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Пример mov eax,123
%%
\begin{frame}{Пример использования команды add}
  \begin{columns}[T]
    \begin{column}[]{0.45\textwidth}  
      \begin{exampleblock}<1->{Пример}
        \begin{center}
\begin{tikzpicture}
  \node[databox=4,text=brown] (EAX1) at (0,0) {256};
  \node[left=0cm of EAX1] (LabelEAX1) {EAX};
  \node<3->[databox=4,text=brown, below=0.4cm of EAX1] (ECX1) {2000};
  \node<3->[left=0cm of ECX1] (LabelECX1) {\only<3,4>{ECX}\only<5,6>{n}};
  \node<1,2>[state, fit=(EAX1) (LabelEAX1)] (State1) {};
  \node<3->[state, fit=(EAX1) (LabelEAX1) (ECX1)] (State1) {};

  \node[databox=4,text=brown, below=2.5cm of EAX1] (EAX2) {\only<1,3,5>{?}\only<2>{379}\only<4>{2256}\only<6>{-2135429428}};
  \node[left=0cm of EAX2] (LabelEAX2) {EAX};
  \node<3->[databox=4,text=brown, below=0.4cm of EAX2] (ECX2) {\only<3,5>{?}\only<4,6>{2000}};
  \node<3->[left=0cm of ECX2] (LabelECX2) {\only<3,4>{ECX}\only<5,6>{n}};
  \node<1,2>[state, fit=(EAX2) (LabelEAX2)] (State2) {};
  \node<3->[state, fit=(EAX2) (LabelEAX2) (ECX2)] (State2) {};

  \node[command] (cmd) at($(State1.south)!0.5!(State2.north)$) {\cl{add eax, \only<1,2>{123}\only<3,4>{ecx}\only<5,6>{n}}};
  \draw[-o] (State1) -- (cmd);
  \draw[->] (cmd) -- (State2);
\end{tikzpicture}
        \end{center}
      \end{exampleblock}
    \end{column}
    \begin{column}[]{0.45\textwidth}  
      \begin{block}<1->{Вопрос}
        Какой результат?
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Команды языка Ассемблер: push
%%
%% TODO: Команды push/pop
%%
\begin{frame}\frametitle{Команды языка Ассемблер: push}
  \begin{block}<1->{Прототип}
    \cl{push \{источник\}}
  \end{block}
  \begin{block}<1->{}
    \begin{itemize}
      \item 
    \end{itemize}
  \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Команды языка Ассемблер: pop
%%
\begin{frame}\frametitle{Команды языка Ассемблер: pop}
  \begin{block}<1->{Прототип}
    \cl{pop \{приёмник\}}
  \end{block}
  \begin{block}<1->{}
    \begin{itemize}
      \item 
    \end{itemize}
  \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Подпрограммы
%%
\section{Подпрограммы}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Соглашение о вызове
%%
\begin{frame}\frametitle{Соглашение о вызове}
  \begin{block}<1->{Определение}
    {\bf Соглашение о вызове} (англ. {\it calling convention}) --- часть двоичного интерфейса приложений (англ. {\it application binary interface, ABI}), которая регламентирует технические особенности вызова подпрограммы, передачи параметров, возврата из подпрограммы и передачи результата вычислений в точку вызова. [Wiki]
  \end{block}
  \begin{block}<2->{}
    Как правило, соглашение о вызове определяется из:
    \begin{itemize}
      \item Архитектуры компьютера (в том числе и разрядности режима процессора).
      \item Операционной системы.
      \item Языка программирования.
    \end{itemize}
  \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Соглашение о вызове
%%
\begin{frame}\frametitle{Соглашение о вызове}
  \begin{block}{Что определяет}
    \begin{itemize}
      \item<1,2,4> Как передать параметры.
      \begin{itemize}
        \item Через регистры или стек.
        \item В каком порядке.
      \end{itemize}
      \item<2,4> Как вернуть результат.
      \begin{itemize}
        \item Через регистры или стек.
        \item Кто выделяет память для больших результатов.
      \end{itemize}
      \item<3-> Какие регистры можно изменить в подпрограмме.
      \item<4> Кто очистит стек, если он использовался для передачи параметров.
      \item<4> Какие суффиксы и префиксы используются для имён подпрограмм.
      \item<4> Какое выравнивание использовать для элементов в стеке/памяти.
      \item<4> Какие типы чисел разрешены.
      \item<4> ...
    \end{itemize}
  \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Соглашение о вызове
%%
\begin{frame}\frametitle{Соглашение о вызове}
  \begin{block}{Примеры}
    \begin{description}
      \item[cdecl] --- Основной способ вызова в Си для 32-бит архитектур.
      \item[pascal] --- Основной способ вызова для Паскаля, также применялся в Windows 3.x..
      \item[fastcall] --- Передача параметров через регистры. Но, Fastcall не стандартизирован!!! И имеет разные модификации в зависемости от архитектуры/языка программирования/ОС.
      \item[stdcall] --- Применяется при вызове функций WinAPI.
      \item[safecall] --- Обеспечивает более удобный для использования в распространённых языках высокого уровня способ вызова методов интерфейсов при использовании модели COM.
      \item[thiscall] --- Используется в компиляторах C++. Обеспечивает передачу аргументов при вызовах методов класса в объектно ориентированной среде.
    \end{description}
  \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Соглашение о вызове
%%
\begin{frame}\frametitle{Соглашение о вызове}
  \begin{block}{cdecl}
    \begin{itemize}
      \item Параметры функции передаются через стек в направлении справа-налево.
      \item Выравнивание параметров: 4 байта.
      \item Результат функции передаются:
      \begin{itemize}
        \item в EAX для данных размером $\le$ 4 байт;
        \item в паре EAX:EDX для данных размером $\le$ 8 байт;
        \item в регистре ST0 математического сопроцессора для действительных чисел;
        \item иначе вызывающая функция выделяет память для результата и помещает адрес в вершину стека (так называемый <<скрытый параметр>>), ожидая что в EAX будет реальный адрес, где сохранился результат.
      \end{itemize}
      \item Вызывающая функция должна очистить стек {\bf самостоятельно}.
      \item Подпрограмма может изменить состояние регистров EAX, ECX и EDX, значения остальных должны быть восстановлены подпрограммой.
      \item Стек математического сопроцессора должен быть пустым перед и после вызова.
    \end{itemize}
  \end{block}
\end{frame}

%% TODO: Команда call

%% TODO: Hello world

%% TODO: Описание примера вызова подпрограммы

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Вызов подпрограммы
%%
\begin{frame}[fragile]\frametitle{Вызов подпрограммы}
  \begin{block}{}
  \begin{figure}
    \begin{tikzpicture}
\node[code,scale=0.5] (code) at (0,0) {%
  \begin{minipage}{1.1\textwidth}
    \begin{lstlisting}[]
        push    ecx     ; <--- y
        push    ebx     ; <--- x
        call    my_sum  ; <--- my_sum(x,y)
        ; тут некая команда
...
my_sum:
        push    ebx     ; Используемые регистры помещаем в стек
        mov     eax, [esp+8]
        mov     ebx, [esp+12]
        add     eax, ebx
        pop     ebx
        ret     8       ; Возвращаемся и удаляем параметры из стека
    \end{lstlisting}
  \end{minipage}
};
\foreach \yy in {1,...,12} {
  \coordinate (l\yy) at (-8pt,-0.5*\yy*\baselineskip+0.25*\baselineskip);
}
\only<1>{\node[databox=1] (EIP) at (0,3*\ByteHeight) {};}
\only<2,3,4,5,6,7,8,9>{\node[databox=1,fill=green!30!white] (EIP) at (0,3*\ByteHeight) {};}
\node[left=0cm of EIP] {EIP};
%
\only<1,2,3,4>{\node[databox=1,text=brown,right=of EIP] (EAX) {?};}
\only<5>{\node[databox=1,text=brown,fill=green!30!white,right=of EIP] {32};}
\only<6>{\node[databox=1,text=brown,fill=green!30!white,right=of EIP] {75};}
\only<7,8,9>{\node[databox=1,text=brown,right=of EIP] (EAX) {75};}
%
\node[left=0cm of EAX] (leax) {EAX};
\only<1,2,3,4,8,9>{\node[databox=1,text=brown,right=of EAX] (EBX) {32};}
\only<5>{\node[databox=1,text=brown,fill=green!30!white,right=of EAX] (EBX) {43};}
\only<6>{\node[databox=1,text=brown,right=of EAX] (EBX) {43};}
\only<7>{\node[databox=1,text=brown,fill=green!30!white,right=of EAX] (EBX) {32};}
%
\node[left=0cm of EBX] {EBX};
\node[databox=1,text=brown,right=of EBX] (ECX) {43};
\node[left=0cm of ECX] {ECX};
\only<1,5,6,9>{\node[databox=1,text=brown,right=of ECX] (ESP) {};}
\only<2,3,4,7,8>{\node[databox=1,fill=green!30!white,text=brown,right=of ECX] (ESP) {};}
\node[left=0cm of ESP] {ESP};
%
\begin{scope}[xshift=-1*\ByteWidht,yshift=1*\ByteHeight,scale=0.6, every node/.style={scale=0.6}]
  \node[partleft] (tmp) at (0,0) {...};
  \only<1,9>{%
    \node[databox=17,fill=lightgray,right=-\pgflinewidth of tmp] (tmp) {};
    \node[databox=1,right=-\pgflinewidth of tmp] (data) {?};
  }
  \only<2>{%
    \node[databox=9,fill=lightgray,right=-\pgflinewidth of tmp] (tmp) {};
    \node[databox=4,fill=green!30!white,right=-\pgflinewidth of tmp] (data2) {32};
    \node[databox=4,fill=green!30!white,right=-\pgflinewidth of data2] (data1) {43};
    \node[databox=1,right=-\pgflinewidth of data1] (data) {?};
  }
  \only<3>{%
    \node[databox=5,fill=lightgray,right=-\pgflinewidth of tmp] (tmp) {};
    \node[databox=4,fill=green!30!white,right=-\pgflinewidth of tmp] (rptr) {return ptr};
    \node[databox=4,right=-\pgflinewidth of rptr] (data2) {32};
    \node[databox=4,right=-\pgflinewidth of data2] (data1) {43};
    \node[databox=1,right=-\pgflinewidth of data1] (data) {?};
  }
  \only<4>{%
    \node[databox=1,fill=lightgray,right=-\pgflinewidth of tmp] (tmp) {};
    \node[databox=4,fill=green!30!white,right=-\pgflinewidth of tmp] (data3) {32};
    \node[databox=4,right=-\pgflinewidth of data3] (rptr) {return ptr};
    \node[databox=4,right=-\pgflinewidth of rptr] (data2) {32};
    \node[databox=4,right=-\pgflinewidth of data2] (data1) {43};
    \node[databox=1,right=-\pgflinewidth of data1] (data) {?};
  }
  \only<5,6>{%
    \node[databox=1,fill=lightgray,right=-\pgflinewidth of tmp] (tmp) {};
    \node[databox=4,right=-\pgflinewidth of tmp] (data3) {32};
    \node[databox=4,right=-\pgflinewidth of data3] (rptr) {return ptr};
    \node[databox=4,right=-\pgflinewidth of rptr] (data2) {32};
    \node[databox=4,right=-\pgflinewidth of data2] (data1) {43};
    \node[databox=1,right=-\pgflinewidth of data1] (data) {?};
  }
  \only<7>{%
    \node[databox=1,fill=lightgray,right=-\pgflinewidth of tmp] (tmp) {};
    \node[databox=4,fill=lightgray,right=-\pgflinewidth of tmp] (tmp) {32};
    \node[databox=4,right=-\pgflinewidth of tmp] (rptr) {return ptr};
    \node[databox=4,right=-\pgflinewidth of rptr] (data2) {32};
    \node[databox=4,right=-\pgflinewidth of data2] (data1) {43};
    \node[databox=1,right=-\pgflinewidth of data1] (data) {?};
  }
  \only<8>{%
    \node[databox=5,fill=lightgray,right=-\pgflinewidth of tmp] (tmp) {};
    \node[databox=4,fill=lightgray,right=-\pgflinewidth of tmp] (rptr) {return ptr};
    \node[databox=8,fill=lightgray,right=-\pgflinewidth of rptr] (tmp) {};
    \node[databox=1,right=-\pgflinewidth of tmp] (data) {?};
  }
  \node[partright,right=-\pgflinewidth of data] {...};
  \node[linkedbyte,right=-\pgflinewidth-0.5*\DeltaWidht of tmp] (headofstack) {};
\end{scope}
%
\only<1>{\draw [->,draw=violet,thick] (EIP) to[out=-90,in=180] (l1);}
\only<2>{\draw [->,draw=violet,thick] (EIP) to[out=-90,in=180] (l3);}
\only<3>{\draw [->,draw=violet,thick] (EIP) to[out=-90,in=180] (l7);}
\only<4>{\draw [->,draw=violet,thick] (EIP) to[out=-90,in=180] (l8);}
\only<5>{\draw [->,draw=violet,thick] (EIP) to[out=-90,in=180] (l10);}
\only<6>{\draw [->,draw=violet,thick] (EIP) to[out=-90,in=180] (l11);}
\only<7>{\draw [->,draw=violet,thick] (EIP) to[out=-90,in=180] (l12);}
\only<8>{\draw [->,draw=violet,thick] (EIP) to[out=-90,in=180] (l4);}
\only<9>{\draw [->,draw=violet,thick] (EIP) to[out=-90,in=180] (l5);}
%
\only<3,4,5,6,7>{\draw [->,draw=violet,thick] (rptr) to[out=-90,in=0] ++(-0.5*\ByteWidht,-0.75*\ByteHeight)
		 -- ++(-3*\ByteWidht,0) to[out=180,in=180] (l4);
}
\only<8>{\draw [->,draw=violet,dotted] (rptr) to[out=-90,in=0] ++(-0.5*\ByteWidht,-0.75*\ByteHeight)
		 -- ++(-3*\ByteWidht,0) to[out=180,in=180] (l4);
}
%
\only<1,8,9>{\draw [->,draw=violet,thick] (ESP) to[out=-90,in=90] (headofstack);}
\only<2,3,4,5,6,7>{\draw [->,draw=violet,thick] (ESP) to[out=-90,in=0] ++(-0.5*\ByteWidht,-\ByteHeight)
       to[out=180,in=0] ($(headofstack)+(0.5*\ByteWidht,\ByteHeight)$)
       to[out=180,in=90] (headofstack);
}
%
\only<2>{\draw [->,draw=blue,dotted] (EBX) to[out=-90,in=90] (data2);}
\only<2>{\draw [->,draw=blue,dotted] (ECX) to[out=-90,in=90] (data1);}
\only<4>{\draw [->,draw=blue,dotted] (EBX) to[out=-90,in=60] (data3);}
\only<5>{\draw [->,draw=blue,dotted] (data2) to[out=135,in=-90] (EAX);}
\only<5>{\draw [->,draw=blue,dotted] (data1) to[out=135,in=-90] (EBX);}
\only<6>{\draw [->,draw=blue,dotted] (EBX) to[out=-120,in=-60] node[below,text=blue,scale=0.5]{32+43} (EAX);}
\only<7>{\draw [->,draw=blue,dotted] (tmp) to[out=60,in=-90] (EBX);}
%
\begin{pgfonlayer}{background}
  \begin{scope}[scale=0.5, every node/.style={scale=0.5, text width=1.1\textwidth}]
    \only<2>{\qahigh{1,2}}
    \only<3>{\qahigh{3}}
    \only<4>{\qahigh{7}}
    \only<5>{\qahigh{8,9}}
    \only<6>{\qahigh{10}}
    \only<7>{\qahigh{11}}
    \only<8>{\qahigh{12}}
    \only<9>{\qahigh{4}}
  \end{scope}
\end{pgfonlayer}
    \end{tikzpicture}
  \end{figure}
  \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% 
%%
\begin{frame}{}
  \vfill
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}Вопросы?
  \end{beamercolorbox}
  \vfill
  \begin{columns}[T]
    \begin{column}[]{0.45\textwidth}  
      \begin{exampleblock}<1->{Сделанов в}
        \begin{center}
           \Huge\LaTeXe
        \end{center}
      \end{exampleblock}
    \end{column}
    \begin{column}[]{0.45\textwidth}  
      \begin{block}<1->{Использовано}
        \begin{itemize}
          \item пакеты: beamer, tikz
          \item строк кода: >1100
        \end{itemize}
      \end{block}
    \end{column}
  \end{columns}
  \vfill
\end{frame}

\end{document}
